<!DOCTYPE html>
<html lang="en">
    <head>
        <base target="_top" />
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <meta property="og:image" content="https://neon-ninja.github.io/shards/screenshot.png" />
        <link
            rel="icon"
            type="image/png"
            href="//commondatastorage.googleapis.com/ingress.com/img/map_icons/marker_images/abaddon1_shard.png"
            sizes="60x60" />
        <title>Ingress Shards</title>
        <link
            rel="stylesheet"
            href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
            integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
            crossorigin="" />
        <link
            rel="stylesheet"
            href="https://cdnjs.cloudflare.com/ajax/libs/github-fork-ribbon-css/0.2.3/gh-fork-ribbon.min.css" />
        <script
            src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
            integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
            crossorigin=""></script>
        <script src="https://unpkg.com/leaflet-providers@latest/leaflet-providers.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.7.1/jquery.min.js"></script>
        <script src="https://neon-ninja.github.io/leaflet.motion/dist/leaflet.motion.min.js"></script>
        <style>
            html,
            body,
            #map {
                height: 100%;
                width: 100%;
                margin: 0;
            }

            button {
                font-family: "Twemoji Country Flags", sans-serif;
            }

            #controls {
                position: absolute;
                right: 10px;
                bottom: 20px;
                background-color: white;
                z-index: 9999;
                padding: 10px;
                border-radius: 10px;
                display: grid;
                grid-template-columns: 1fr;
                min-width: 15%;
                min-height: 10%;
            }

            #controls #loading-overlay {
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.7);
                color: white;
                display: flex;
                flex-direction: column;
                justify-content: center;
                align-items: center;
                z-index: 10;
                border-radius: 10px;
            }

            #controls #loading-overlay h3 {
                margin-block: 0 0.5em;
            }

            #controls #loading-progress {
                width: 80%;
                margin-top: 5px;
            }

            #controls span {
                font-weight: bold;
            }

            .github-fork-ribbon:before {
                background-color: #333;
            }
        </style>
    </head>

    <body>
        <script type="module" defer>
            import { polyfillCountryFlagEmojis } from "https://cdn.skypack.dev/country-flag-emoji-polyfill";
            polyfillCountryFlagEmojis();
        </script>
        <div id="map"></div>
        <div id="controls">
            <div id="loading-overlay">
                <h3 id="loading-message">Loading Shard Data...</h3>
                <progress id="loading-progress" value="0" max="100"></progress>
            </div>

            <select id="series">
                <option value="custom">Custom</option>
            </select>
            <br />
            <input id="custom" class="series" type="file" accept="application/json" style="display: none" />
        </div>
        <a
            class="github-fork-ribbon"
            href="https://github.com/neon-ninja/shards"
            data-ribbon="Fork me on GitHub"
            title="Fork me on GitHub"
            >Fork me on GitHub</a
        >

        <script type="module">
            import { shardSeries, getSeriesSafeName } from "./shard-series-metadata.js";

            window.map = L.map("map", {
                worldCopyJump: true,
            }).fitWorld();
            var baseMaps = {
                OSM: L.tileLayer.provider("OpenStreetMap.Mapnik"),
                "CartoDB Positron": L.tileLayer.provider("CartoDB.Positron"),
                "CartoDB Dark Matter": L.tileLayer.provider("CartoDB.DarkMatter").addTo(map),
                "ESRI WorldImagery": L.tileLayer.provider("Esri.WorldImagery"),
                "Google Hybrid": L.tileLayer("http://{s}.google.com/vt/lyrs=s,h&x={x}&y={y}&z={z}", {
                    maxZoom: 20,
                    subdomains: ["mt0", "mt1", "mt2", "mt3"],
                }),
            };
            const factionColors = {
                NEU: "#FF6600",
                RES: "#0088FF",
                ENL: "#03DC03",
                MAC: "#FF0028",
                NOT_SPECIFIED: "#FF6600",
                undefined: "#FF6600",
            };
            const layerControl = L.control.layers(baseMaps, {}, { position: "topleft" }).addTo(map);

            const shardIcon = L.icon({
                iconUrl:
                    "//commondatastorage.googleapis.com/ingress.com/img/map_icons/marker_images/abaddon1_shard.png",
                iconSize: [30, 30],
                iconAnchor: [15, 15],
            });

            window.layer_lookup = {};
            let currentActiveSeriesLayer = null;
            let _shardSeriesData = {};
            let jsonParserWorker = null;

            async function initDataPipeline() {
                try {
                    _shardSeriesData = await loadAndParseShardData();
                    console.debug(
                        `Shard data loaded successfully: ${_shardSeriesData.length} series, ${
                            _shardSeriesData.flatMap((event) => event.sites || []).length
                        } sites`
                    );
                    renderSeriesSelection();

                    let prioritySeriesDetails = getPrioritySeriesDetails(location.hash);
                    let data = _shardSeriesData.find((e) => e.name === prioritySeriesDetails.seriesSafeName);
                    if (!data) {
                        console.warn(
                            `Priority series ${prioritySeriesDetails.seriesSafeName} not found, defaulting to latest series`
                        );
                        prioritySeriesDetails = getPrioritySeriesDetails();
                        data = _shardSeriesData.find((e) => e.name === prioritySeriesDetails.seriesSafeName);
                    }
                    prioritySeriesDetails.data = data;

                    if (prioritySeriesDetails.data) {
                        console.log(`Rendering priority series: ${prioritySeriesDetails.seriesSafeName}`);
                        renderSeriesData(prioritySeriesDetails.seriesSafeName, prioritySeriesDetails.data);

                        $("#series").one("seriesDisplayComplete", () => {
                            console.debug(
                                `Series display complete. ${
                                    location.hash.length > 0 ? `Displaying site ${location.hash}` : ""
                                }`
                            );
                            if ($(location.hash).length > 0) {
                                $(location.hash).click();
                            }
                        });

                        $("#series").val(prioritySeriesDetails.seriesSafeName);
                        displaySeries(prioritySeriesDetails.seriesSafeName, "page_load");
                    }

                    renderBackgroundSeries(prioritySeriesDetails);
                } catch (error) {
                    console.error("Error loading shard data:", error);
                    loadingProgress.value = 0;
                }
            }

            async function loadAndParseShardData() {
                const startTime = performance.now();
                updateLoadingDetails(0, "Loading Shard Data...");

                const response = await fetch("processed_shard_series.json");
                if (!response.ok) {
                    console.error("Failed to fetch processed_shard_series.json:", response.statusText);
                    return;
                }
                const fetchTime = performance.now();
                console.debug(`Data fetch time is : ${fetchTime - startTime} milliseconds`);

                const contentLength = response.headers.get("content-length");
                const total = parseInt(contentLength, 10);
                let loaded = 0;

                const reader = response.body.getReader();
                const chunks = [];

                while (true) {
                    const { done, value } = await reader.read();
                    if (done) {
                        break;
                    }
                    chunks.push(value);
                    loaded += value.length;
                    updateLoadingDetails((loaded / total) * 33);
                }

                const combinedChunks = concatUint8Arrays(chunks);
                const rawJsonString = new TextDecoder().decode(combinedChunks);
                updateLoadingDetails(33);

                return new Promise((resolve, reject) => {
                    jsonParserWorker = new Worker("json-parser-worker.js", { type: "module" });

                    jsonParserWorker.onmessage = (event) => {
                        if (event.data.status === "complete") {
                            const parseTime = performance.now();
                            console.debug(`Data parse time is : ${parseTime - fetchTime} milliseconds`);
                            updateLoadingDetails(66, "Rendering shard data...");

                            resolve(event.data.data);
                        } else if (event.data.status === "error") {
                            console.error("Web Worker error:", event.data.message);
                            updateLoadingDetails(0, "Error loading shard data.");
                            reject(new Error(event.data.message));
                        }
                    };

                    jsonParserWorker.onerror = (error) => {
                        console.error("Web Worker general error:", error);
                        updateLoadingDetails(0, "Error loading shard data.");
                        reject(error);
                    };

                    jsonParserWorker.postMessage({ rawData: rawJsonString });
                });
            }

            // --- Helper function to concatenate Uint8Arrays ---
            function concatUint8Arrays(arrays) {
                let totalLength = 0;
                for (const arr of arrays) {
                    totalLength += arr.length;
                }
                const result = new Uint8Array(totalLength);
                let offset = 0;
                for (const arr of arrays) {
                    result.set(arr, offset);
                    offset += arr.length;
                }
                return result;
            }

            function renderSeriesSelection() {
                const shardSeriesNames = shardSeries.flatMap((s) => s.seriesName);
                for (const seriesName of shardSeriesNames) {
                    $("#series").append(`<option value="${getSeriesSafeName(seriesName)}">${seriesName}</option>`);
                }
            }

            function updateLoadingDetails(progress, message) {
                const loadingOverlay = document.getElementById("loading-overlay");
                const loadingMessage = document.getElementById("loading-message");
                const loadingProgress = document.getElementById("loading-progress");

                if (progress !== undefined) {
                    loadingProgress.value = progress;
                }
                if (message) {
                    loadingMessage.textContent = message;
                }
                if (progress >= 100) {
                    setTimeout(() => (loadingOverlay.style.display = "none"), 500);
                } else {
                    loadingOverlay.style.display = "flex";
                }
            }

            function getPrioritySeriesDetails(locationHash) {
                let siteName =
                    locationHash && locationHash.substring(1).replace("Abaddon_1", "").replace("abaddon1_", "");
                let seriesSafeName = getSeriesSafeName(shardSeries.at(-1).seriesName);
                if (siteName) {
                    seriesSafeName = siteName.split("_").slice(0, -1).join("_");
                }
                return {
                    seriesSafeName,
                    siteName,
                };
            }

            async function renderSeriesData(name, shardEventData) {
                const startTime = performance.now();
                const seriesLayer = L.featureGroup();
                layer_lookup[name] = seriesLayer;
                layerControl.addOverlay(seriesLayer, name);

                let controlsHtml = `<div id="${name}" class="series" style="display:none">`;

                console.debug(`Rendering sites for series: ${name}`);
                for (const [index, site] of shardEventData.sites.entries()) {
                    console.debug(`Rendering site: ${site.name} (${site.id})`);
                    const siteLayer = L.featureGroup().addTo(seriesLayer);
                    siteLayer.data = site;

                    const linkedPortalColors = new Map();
                    for (const shard of site.movingShards) {
                        const renderedLinks = renderShardLinks({
                            shard,
                            site,
                            linkedPortalColors,
                        });

                        if (renderedLinks.length > 0) {
                            const movingShard = renderMovingShard(renderedLinks);
                            movingShard.forEach((shard) => shard.addTo(siteLayer));
                            renderedLinks.forEach((polyline) => polyline.addTo(siteLayer));
                        }
                    }

                    for (const portal of site.portals) {
                        const lastKnownTeam = getLastKnownTeam(portal);
                        renderPortal({
                            portal,
                            color: factionColors[lastKnownTeam] || factionColors.NEU,
                            timezone: site.timezone,
                            hasUnmovedShard: !linkedPortalColors.has(portal.id),
                        }).forEach((marker) => marker.addTo(siteLayer));
                    }

                    const uniqueSiteId = name + "_" + site.id.replace(" ", "_");
                    layer_lookup[uniqueSiteId] = siteLayer;
                    const scoresHtml = `<span style="color:${factionColors.RES}">${site.linkScores.RES}</span>:<span style="color:${factionColors.ENL}">${site.linkScores.ENL}</span>:<span style="color:${factionColors.MAC}">${site.linkScores.MAC}</span>:<span style="color:${factionColors.NEU}">${site.linkScores.NEU}</span>`;
                    controlsHtml += `<button id="${uniqueSiteId}">${site.name}</button> ${scoresHtml}<br>`;
                }
                controlsHtml += "</div>";
                $("#controls").append(controlsHtml);

                const endTime = performance.now();
                console.debug(
                    `Render of ${name} (${shardEventData.sites.length} sites) complete in ${
                        endTime - startTime
                    } milliseconds`
                );
            }

            function renderShardLinks(shardDetails) {
                const site = shardDetails.site;
                const shard = shardDetails.shard;
                const linkedPortalColors = shardDetails.linkedPortalColors;

                return (
                    shard.links.map((link) => {
                        const originPortal = site.portals.find((portal) => portal.id === link.origin);
                        const destPortal = site.portals.find((portal) => portal.id === link.dest);
                        if (!originPortal || !destPortal) {
                            console.warn(`Missing portal data for link: ${link.origin} to ${link.dest}`);
                            return;
                        }

                        const linkColor = factionColors[link.linkTeam] || factionColors.NEU;
                        const polyline = L.polyline(
                            [L.latLng(originPortal.lat, originPortal.lng), L.latLng(destPortal.lat, destPortal.lng)],
                            {
                                color: linkColor,
                                dashArray: ["10,5,5,5,5,5,5,5,100000"],
                            }
                        );

                        const linkCreationTimeMs = new Date(parseInt(link.link) * 1000).toLocaleString(
                            navigator.language,
                            {
                                timeZone: site.timezone,
                            }
                        );
                        const moveTimeMs = new Date(parseInt(link.move) * 1000).toLocaleString(navigator.language, {
                            timeZone: site.timezone,
                        });
                        const linkTooltip = `<strong>Shard ${shard.id}</strong><br />${originPortal.title} -> ${
                            destPortal.title
                        }<br>Link time: ${linkCreationTimeMs}<br />Jump time: ${moveTimeMs}<br />Distance: ${(
                            Math.round((link.distance + Number.EPSILON) * 100) / 100
                        ).toLocaleString()}m<br />Points: ${link.points}`;
                        polyline.bindTooltip(linkTooltip, { sticky: true });
                        polyline.bindPopup(linkTooltip, { sticky: true });

                        linkedPortalColors.set(link.origin, linkColor);
                        linkedPortalColors.set(link.dest, linkColor);

                        return polyline;
                    }) || null
                );
            }

            function getLastKnownTeam(portal) {
                if (!portal || !portal.shardHistory) {
                    return undefined;
                }

                const allHistoryEntries = portal.shardHistory
                    .flatMap((shard) => shard.history || [])
                    .filter((entry) => entry.reason !== "despawn" && entry.team)
                    .sort((a, b) => b.time - a.time);

                return allHistoryEntries[0]?.team;
            }

            function renderMovingShard(renderedLinks) {
                const coords = renderedLinks.map((line) => line.getLatLngs()).flat();
                const animatedShards = [
                    L.motion.polyline(
                        coords,
                        {
                            color: "transparent",
                            interactive: false,
                        },
                        { auto: true, duration: renderedLinks.length * 1000 },
                        {
                            showMarker: true,
                            removeOnEnd: false,
                            icon: shardIcon,
                            interactive: false,
                        }
                    ),
                ];
                for (const polyline of renderedLinks) {
                    polyline.animatedShards = animatedShards;
                    polyline.on("mouseover", function (e) {
                        this.animatedShards.forEach((s) => s.motionStart());
                    });
                }
                return animatedShards;
            }

            function renderPortal(portalDetails) {
                const portal = portalDetails.portal;
                const latLng = L.latLng(portal.lat, portal.lng);
                let portalTooltip = `<strong>${portal.title}</strong><br />`;
                for (const shardHistoryItem of portal.shardHistory || []) {
                    portalTooltip += `<hr /><strong>Shard ${shardHistoryItem.id}</strong><br />`;
                    for (const historyItem of shardHistoryItem.history) {
                        let teamToDisplay;
                        if (historyItem.reason !== "no move") {
                            teamToDisplay = historyItem.team || "NEU";
                        }
                        portalTooltip += `${historyItem.reason === "link" ? "jump" : historyItem.reason} at ${new Date(
                            parseInt(historyItem.time) * 1000
                        ).toLocaleString(navigator.language, {
                            timeZone: portalDetails.timezone,
                        })}${
                            teamToDisplay
                                ? ` - <span style="color:${factionColors[teamToDisplay]}">${teamToDisplay}</span>`
                                : ""
                        } <br />`;
                    }
                }

                const markers = [L.circleMarker(latLng, { color: portalDetails.color }).bindTooltip(portalTooltip)];
                if (portalDetails.hasUnmovedShard) {
                    markers.push(L.marker(latLng, { icon: shardIcon }).bindTooltip(portalTooltip));
                }
                return markers;
            }

            let backgroundRenderQueue = [];
            let totalSeriesToRender = 0;
            let seriesRendered = 0;

            async function renderBackgroundSeries(prioritySeries) {
                const seriesToRender = _shardSeriesData.filter((event) => {
                    return getSeriesSafeName(event.name) !== prioritySeries.seriesSafeName;
                });

                seriesToRender.forEach((event) => {
                    backgroundRenderQueue.push({ event, safeName: getSeriesSafeName(event.name) });
                });
                totalSeriesToRender = backgroundRenderQueue.length;
                console.log(`Total series to render in background: ${totalSeriesToRender}`);
                seriesRendered = 0;

                requestIdleCallback(renderNextSeries);
            }

            async function renderNextSeries(deadline) {
                while (deadline.timeRemaining() > 0 && backgroundRenderQueue.length > 0) {
                    const nextItem = backgroundRenderQueue.shift();
                    const { event, safeName } = nextItem;

                    renderSeriesData(safeName, event);
                    seriesRendered++;
                    updateLoadingDetails(66 + (seriesRendered / totalSeriesToRender) * 34);

                    if (seriesRendered % 2 === 0) {
                        await new Promise(requestAnimationFrame);
                    }
                }

                if (backgroundRenderQueue.length > 0) {
                    requestIdleCallback(renderNextSeries);
                } else {
                    console.log("Background rendering complete.");
                    updateLoadingDetails(100);
                }
            }

            async function displaySeries(seriesName, source = "user") {
                console.debug(`Displaying series layer for: ${seriesName}`);
                $(".series").hide();

                $(`#${seriesName}`).show();
                $("button").off("click").on("click", buttonHandler).css("font-weight", "normal");

                if (currentActiveSeriesLayer && map.hasLayer(currentActiveSeriesLayer)) {
                    map.removeLayer(currentActiveSeriesLayer);
                }
                const newSeriesLayer = layer_lookup[seriesName];
                if (newSeriesLayer) {
                    layer_lookup[seriesName].addTo(map);
                    currentActiveSeriesLayer = newSeriesLayer;

                    if (source === "user" || location.hash === "" || !layer_lookup[location.hash.substring(1)]) {
                        map.fitBounds(currentActiveSeriesLayer.getBounds());
                    }

                    $("#series").trigger("seriesDisplayComplete");
                } else {
                    console.warn(`No layer found for series: ${seriesName}`);
                }
            }

            function buttonHandler() {
                $(this).css("font-weight", "bold");
                $(this).siblings("button").css("font-weight", "normal");

                var layer = layer_lookup[this.id];
                map.fitBounds(layer.getBounds());
                location.hash = this.id;
                layer.eachLayer(function (l) {
                    if (l instanceof L.Polyline) {
                        if (l.animatedShards) l.animatedShards.forEach((s) => s.motionStart());
                    }
                });
                var d = layer.data;
            }

            async function handleCustomFile() {
                var file = this.files[0];
                if (!file) return;

                updateLoadingDetails(0, "Loading custom shard data...");
                await new Promise(requestAnimationFrame);

                let reader = new FileReader();
                reader.onload = async function (e) {
                    const localRawJsonString = e.target.result;
                    updateLoadingDetails(33);
                    await new Promise(requestAnimationFrame);

                    const seriesSafeName = getSeriesSafeName(file.name);
                    jsonParserWorker.postMessage({
                        rawData: localRawJsonString,
                        seriesSafeName,
                        processType: "custom_file",
                    });
                    jsonParserWorker.onmessage = async (workerEvent) => {
                        if (workerEvent.data.status === "complete") {
                            updateLoadingDetails(66, "Rendering shard data...");
                            await new Promise(requestAnimationFrame);

                            const customShardSeriesData = workerEvent.data.data;

                            _shardSeriesData[seriesSafeName] = customShardSeriesData;
                            renderSeriesData(seriesSafeName, customShardSeriesData);

                            $("#series").append(`<option value="${seriesSafeName}">${file.name}</option>`);
                            $("#series").val(seriesSafeName).change();
                            $("button").off("click").on("click", buttonHandler);

                            updateLoadingDetails(100);
                        }
                    };
                };
                reader.readAsText(file);
            }

            $(() => {
                $("#custom").change(handleCustomFile);
                $("#series").on("change", function () {
                    displaySeries(this.value);
                });

                initDataPipeline();
            });
        </script>
    </body>
</html>
