<!DOCTYPE html>
<html lang="en">
    <head>
        <base target="_top" />
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <meta property="og:image" content="https://neon-ninja.github.io/shards/screenshot.png" />
        <link
            rel="icon"
            type="image/png"
            href="//commondatastorage.googleapis.com/ingress.com/img/map_icons/marker_images/abaddon1_shard.png"
            sizes="60x60" />
        <title>Ingress Shards</title>
        <link
            rel="stylesheet"
            href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
            integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
            crossorigin="" />
        <link
            rel="stylesheet"
            href="https://cdnjs.cloudflare.com/ajax/libs/github-fork-ribbon-css/0.2.3/gh-fork-ribbon.min.css" />
        <script
            src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
            integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
            crossorigin=""></script>
        <script src="https://unpkg.com/leaflet-providers@latest/leaflet-providers.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.7.1/jquery.min.js"></script>
        <script src="https://neon-ninja.github.io/leaflet.motion/dist/leaflet.motion.min.js"></script>
        <style>
            html,
            body,
            #map {
                height: 100%;
                width: 100%;
                margin: 0;
            }

            button {
                font-family: "Twemoji Country Flags", sans-serif;
            }

            #controls {
                position: absolute;
                right: 10px;
                bottom: 20px;
                background-color: white;
                z-index: 9999;
                padding: 10px;
                border-radius: 10px;
                display: grid;
                grid-template-columns: 1fr;
                min-width: 15%;
                min-height: 10%;
            }

            #controls #loading-overlay {
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.7);
                color: white;
                display: flex;
                flex-direction: column;
                justify-content: center;
                align-items: center;
                z-index: 10;
                border-radius: 10px;
            }

            #controls #loading-overlay h3 {
                margin-block: 0 0.5em;
            }

            #controls #loading-progress {
                width: 80%;
                margin-top: 5px;
            }

            #controls span {
                font-weight: bold;
            }

            .github-fork-ribbon:before {
                background-color: #333;
            }
        </style>
    </head>

    <body>
        <script type="module" defer>
            import { polyfillCountryFlagEmojis } from "https://cdn.skypack.dev/country-flag-emoji-polyfill";
            polyfillCountryFlagEmojis();
        </script>
        <div id="map"></div>
        <div id="controls">
            <div id="loading-overlay">
                <h3>Loading Shard Data...</h3>
                <progress id="loading-progress" value="0" max="100"></progress>
            </div>

            <select id="series">
                <option value="custom">Custom</option>
            </select>
            <br />
            <input id="custom" class="series" type="file" accept="application/json" style="display: none" />
        </div>
        <a
            class="github-fork-ribbon"
            href="https://github.com/neon-ninja/shards"
            data-ribbon="Fork me on GitHub"
            title="Fork me on GitHub"
            >Fork me on GitHub</a
        >

        <script type="module">
            window.map = L.map("map", {
                worldCopyJump: true,
            }).fitWorld();
            var baseMaps = {
                OSM: L.tileLayer.provider("OpenStreetMap.Mapnik"),
                "CartoDB Positron": L.tileLayer.provider("CartoDB.Positron"),
                "CartoDB Dark Matter": L.tileLayer.provider("CartoDB.DarkMatter").addTo(map),
                "ESRI WorldImagery": L.tileLayer.provider("Esri.WorldImagery"),
                "Google Hybrid": L.tileLayer("http://{s}.google.com/vt/lyrs=s,h&x={x}&y={y}&z={z}", {
                    maxZoom: 20,
                    subdomains: ["mt0", "mt1", "mt2", "mt3"],
                }),
            };
            const factionColors = {
                NEUTRAL: "#FF6600",
                RESISTANCE: "#0088FF",
                ENLIGHTENED: "#03DC03",
                MACHINA: "#FF0028",
                NOT_SPECIFIED: "#FF6600",
                undefined: "#FF6600",
            };
            const historyReasons = {
                SPAWN: "spawn",
                NO_MOVE: "no move",
                LINK: "link",
                JUMP: "jump",
                DESPAWN: "despawn",
            };
            const shardEventType = {
                SKIRMISH: "skirmish",
                SINGULAR: "singular",
                ANOMALY: "anomaly",
            };
            var layerControl = L.control.layers(baseMaps, {}, { position: "topleft" }).addTo(map);

            var shardIcon = L.icon({
                iconUrl:
                    "//commondatastorage.googleapis.com/ingress.com/img/map_icons/marker_images/abaddon1_shard.png",
                iconSize: [30, 30],
                iconAnchor: [15, 15],
            });

            var shard_singulars = [
                "ðŸ‡¦ðŸ‡º Hervey Bay, Australia",
                "ðŸ‡¦ðŸ‡º Hobart, Australia",
                "ðŸ‡¯ðŸ‡µ Niigata, Japan",
                "ðŸ‡¯ðŸ‡µ Shizuoka, Japan",
                "ðŸ‡¨ðŸ‡³ Shanghai (Baoshan District), China",
                "ðŸ‡²ðŸ‡¾ Kota Kinabalu, Malaysia",
                "ðŸ‡­ðŸ‡° Tuen Mun, Hong Kong",
                "ðŸ‡¸ðŸ‡¬ Bedok, Singapore",
                "ðŸ‡¨ðŸ‡± Santiago, Chile",
                "ðŸ‡µðŸ‡ª Lima, Peru",
                "ðŸ‡¨ðŸ‡¦ Toronto, Canada",
                "ðŸ‡¨ðŸ‡· San Jose, Costa Rica",
                "ðŸ‡²ðŸ‡½ Monterrey, Mexico",
                "ðŸ‡ºðŸ‡¸ Salt Lake City, UT, USA",
                "ðŸ‡ºðŸ‡¸ Las Vegas, NV, USA",
                "ðŸ‡ºðŸ‡¸ San Diego, CA, USA",
                "ðŸ‡³ðŸ‡¿ Greymouth, New Zealand",
                "ðŸ‡¯ðŸ‡µ Shimonoseki, Japan",
                "ðŸ‡°ðŸ‡· Incheon, South Korea",
                "ðŸ‡®ðŸ‡© Makassar, Indonesia",
                "ðŸ‡¹ðŸ‡¼ Kinmen, Taiwan",
                "ðŸ‡¨ðŸ‡³ Tianjin, China",
                "ðŸ‡²ðŸ‡´ Macao",
                "ðŸ‡²ðŸ‡» Male, Maldives",
                "ðŸ‡¦ðŸ‡ª Dubai, United Arab Emirates",
                "ðŸ‡§ðŸ‡¬ Sofia, Bulgaria",
                "ðŸ‡¨ðŸ‡¿ Ostrava, Czechia",
                "ðŸ‡¸ðŸ‡° Bratislava, Slovakia",
                "ðŸ‡³ðŸ‡± Delfzijl, Netherlands",
                "ðŸ‡³ðŸ‡´ Stavanger, Norway",
                "ðŸ‡§ðŸ‡ª Ghent, Belgium",
                "ðŸ‡ªðŸ‡¸ Zaragoza, Spain",
                "ðŸ‡±ðŸ‡» Riga, Latvia",
                "ðŸ‡¿ðŸ‡¦ Cape Town, South Africa",
                "ðŸ‡µðŸ‡± PoznaÅ„, Poland",
                "ðŸ‡®ðŸ‡¹ Fiumicino, Italy",
                "ðŸ‡©ðŸ‡ª NÃ¼rnberg, Germany",
                "ðŸ‡«ðŸ‡· Lyon, France",
                "ðŸ‡¬ðŸ‡§ Plymouth, UK",
                "ðŸ‡µðŸ‡¹ Lisboa, Portugal",
                "ðŸ‡§ðŸ‡· Recife, Brazil",
                "ðŸ‡§ðŸ‡· Rio de Janeiro, Brazil",
                "ðŸ‡¨ðŸ‡´ Cartagena, Colombia",
                "ðŸ‡ºðŸ‡¸ Orlando, FL, USA",
                "ðŸ‡ºðŸ‡¸ Columbus, OH, USA",
                "ðŸ‡ºðŸ‡¸ Milwaukee, WI, USA",
                "ðŸ‡ºðŸ‡¸ Fort Worth, TX, USA",
                "ðŸ‡¨ðŸ‡¦ Vancouver, Canada",
            ];
            const linkScoringRules = new Map()
                .set(shardEventType.SINGULAR, {
                    rules: [
                        {
                            description:
                                "3 points for a single jump over a Link longer than 100km. No further points will be given for subsequent jumps by that Shard.",
                            jumpPoints: 0,
                            minDistance: 100000,
                            maxDistance: Infinity,
                            linkLengthPoints: 3,
                            allowFurtherPoints: false,
                        },
                        {
                            description: "1 point for each jump over a Link between 1km and 5km in length.",
                            jumpPoints: 0,
                            minDistance: 1000,
                            maxDistance: 5000,
                            linkLengthPoints: 1,
                            allowFurtherPoints: true,
                        },
                    ],
                })
                .set(shardEventType.SKIRMISH, {
                    rules: [
                        {
                            description: "1 point for a single jump over a Link longer than 249.5m.",
                            jumpPoints: 0,
                            minDistance: 249.5,
                            maxDistance: Infinity,
                            linkLengthPoints: 1,
                            allowFurtherPoints: true,
                        },
                    ],
                })
                .set(shardEventType.ANOMALY, {
                    rules: [
                        {
                            description: "1 point for a single jump.",
                            jumpPoints: 1,
                            minDistance: 0,
                            maxDistance: Infinity,
                            linkLengthPoints: 0,
                            allowFurtherPoints: true,
                        },
                    ],
                });

            window.layer_lookup = {};
            let currentActiveSeriesLayer = null;

            let _shardEventData = {};

            // Web Worker instance
            let jsonParserWorker = null;

            // UI elements
            const loadingOverlay = document.getElementById("loading-overlay");
            const loadingProgress = document.getElementById("loading-progress");

            // A function to convert Niantic's shard jump times json into a more usable format for display on a map.
            function processShardEventData(name, json) {
                const artifacts = json.artifact.filter((d) => d.fragment);
                if (!artifacts.length) {
                    console.warn(`No artifacts found with shards for ${name}. Skipping processing.`);
                    return new Map();
                }

                artifacts.sort((a, b) => a.name.localeCompare(b.name));
                let eventData = new Map();
                for (const artifact of artifacts) {
                    if (!artifact.city && !name.includes("singular")) {
                        console.debug(`Skipping shard singular event ${artifact.id} to separate in drop down box`);
                        continue;
                    }
                    if (artifact.city && name.includes("singular")) {
                        console.debug(
                            `Skipping shard skirmish ${artifact.id} (${artifact.city}) to separate in drop down box`
                        );
                        continue;
                    }

                    const anomalyEventNames = [
                        "theta_2025_06_14",
                        "delta_2025_08_16",
                        "delta_2025_08_23",
                        "delta_2025_09_20",
                    ];

                    const sortedFragments = artifact.fragment.sort((a, b) => a.id.localeCompare(b.id));
                    let site;
                    for (const [index, fragment] of sortedFragments.entries()) {
                        let siteDetails;
                        if (artifact.city) {
                            const eventType = anomalyEventNames.some((nameToFind) => name.includes(nameToFind))
                                ? shardEventType.ANOMALY
                                : shardEventType.SKIRMISH;
                            siteDetails = {
                                ...artifact,
                                eventType,
                            };
                        } else {
                            siteDetails = {
                                ...fragment,
                                city: getShardSingularCity(name, index),
                                eventType: shardEventType.SINGULAR,
                            };
                        }
                        site = getOrCreateSite(eventData, siteDetails);

                        const shardHistory = fragment.history.sort((a, b) => a.moveTimeMs.localeCompare(b.moveTimeMs));
                        let mostRecentShardPortalKey;
                        let shardEntries = [];
                        let allowFurtherPoints = true;
                        for (const historyItem of shardHistory) {
                            const originPortalKey =
                                historyItem.originPortalInfo &&
                                `${historyItem.originPortalInfo.latE6}_${historyItem.originPortalInfo.lngE6}`;
                            const destinationPortalKey =
                                historyItem.destinationPortalInfo &&
                                `${historyItem.destinationPortalInfo.latE6}_${historyItem.destinationPortalInfo.lngE6}`;

                            let originPortal;
                            switch (historyItem.reason) {
                                case historyReasons.SPAWN:
                                    /*
                                        Create a new shard entry if a spawn entry is found.
                                        This covers the instances where Niantic reuse shards within an event
                                        i.e. 65 shards for a 78 shard anomaly!
                                    */
                                    shardEntries.push({
                                        id: fragment.id,
                                        links: new Map(),
                                    });

                                    const destinationPortal = getOrCreatePortalForSite(
                                        site,
                                        destinationPortalKey,
                                        historyItem.destinationPortalInfo,
                                        historyItem.destinationCapturerTeam
                                    );

                                    addToPortalHistory(destinationPortal, fragment.id, historyItem);
                                    mostRecentShardPortalKey = destinationPortalKey;
                                    break;
                                case historyReasons.NO_MOVE:
                                    originPortal = getOrCreatePortalForSite(
                                        site,
                                        mostRecentShardPortalKey,
                                        historyItem.originPortalInfo,
                                        historyItem.originCapturerTeam
                                    );

                                    addToPortalHistory(originPortal, fragment.id, historyItem);
                                    break;
                                case historyReasons.LINK:
                                case historyReasons.JUMP:
                                    originPortal = getOrCreatePortalForSite(
                                        site,
                                        originPortalKey,
                                        historyItem.originPortalInfo,
                                        historyItem.originCapturerTeam
                                    );
                                    const destPortal = getOrCreatePortalForSite(
                                        site,
                                        destinationPortalKey,
                                        historyItem.destinationPortalInfo,
                                        historyItem.destinationCapturerTeam
                                    );
                                    const originLatLng = L.latLng(originPortal.lat, originPortal.lng);
                                    const destLatLng = L.latLng(destPortal.lat, destPortal.lng);
                                    const distance = originLatLng.distanceTo(destLatLng);

                                    let points = 0;
                                    if (allowFurtherPoints) {
                                        const linkRule = getLinkRule(linkScoringRules.get(site.eventType), distance);
                                        if (linkRule) {
                                            points = linkRule.jumpPoints + linkRule.linkLengthPoints;
                                            allowFurtherPoints = linkRule.allowFurtherPoints;
                                        }
                                    }

                                    const linkKey = `${originPortalKey}_${destinationPortalKey}`;
                                    if (!shardEntries[shardEntries.length - 1].links.has(linkKey)) {
                                        shardEntries[shardEntries.length - 1].links.set(linkKey, {
                                            originPortal: originPortalKey,
                                            destinationPortal: destinationPortalKey,
                                            linkCreatorTeam: historyItem.linkCreatorTeam,
                                            linkCreationTimeMs: historyItem.linkCreationTimeMs,
                                            moveTimeMs: historyItem.moveTimeMs,
                                            distance,
                                            points,
                                        });
                                    } else {
                                        console.warn(`Link already exists for key: ${linkKey}`);
                                    }

                                    if (points > 0) {
                                        const moveTimeMs = new Date(parseInt(historyItem.moveTimeMs)).toLocaleString(
                                            navigator.language,
                                            {
                                                timeZone: site.timezone,
                                            }
                                        );

                                        console.debug(
                                            `${artifact.id}: Adding ${historyItem.linkCreatorTeam} link from ${originPortalKey} to ${destinationPortalKey} (${distance}m) at ${moveTimeMs} with points: ${points}`
                                        );

                                        switch (historyItem.linkCreatorTeam) {
                                            case "RESISTANCE":
                                                site.linkScores.RESISTANCE += points;
                                                break;
                                            case "MACHINA":
                                                site.linkScores.MACHINA += points;
                                                break;
                                            case "ENLIGHTENED":
                                                site.linkScores.ENLIGHTENED += points;
                                                break;
                                            default:
                                                site.linkScores.NEUTRAL += points;
                                        }
                                    }

                                    mostRecentShardPortalKey = destinationPortalKey;
                                    break;
                                case historyReasons.DESPAWN:
                                    originPortal = getOrCreatePortalForSite(
                                        site,
                                        originPortalKey,
                                        historyItem.originPortalInfo,
                                        historyItem.originCapturerTeam
                                    );
                                    addToPortalHistory(originPortal, fragment.id, historyItem);
                                    break;
                                default:
                                    console.warn(`Unknown reason for ${shard.id}: ${historyItem.reason}`);
                            }
                        }
                        site.shards.push(...shardEntries);
                    }
                    const linkCount = site.shards.reduce((totalLinks, shard) => totalLinks + shard.links.size, 0);
                    console.debug(
                        `Site ${site.name} has ${site.shards.length} shards, ${site.portals.size} portals and ${linkCount} links.`
                    );
                }
                console.debug(calculateJsonSizeReduction(name, json, eventData));
                return eventData;
            }

            function getOrCreateSite(eventData, siteDetails) {
                const siteId = siteDetails.id;
                if (!eventData.has(siteId)) {
                    console.debug("Creating new site: ", siteDetails);
                    eventData.set(siteId, {
                        name: siteDetails.city || "Unknown",
                        timezone: siteDetails.timezone || "UTC",
                        eventType: siteDetails.eventType,
                        portals: new Map(),
                        shards: [],
                        linkScores: {
                            RESISTANCE: 0,
                            ENLIGHTENED: 0,
                            MACHINA: 0,
                            NEUTRAL: 0,
                        },
                    });
                }
                return eventData.get(siteId);
            }

            function getShardSingularCity(name, index) {
                let lookupId = index;
                if (name == "_theta_2025_05_31_shard_singular") lookupId += 16;
                if (name == "_theta_2025_06_07_shard_singular") lookupId += 32;
                return shard_singulars[lookupId];
            }

            function getOrCreatePortalForSite(site, portalKey, portalInfo, capturerTeam) {
                if (!site.portals.has(portalKey)) {
                    site.portals.set(portalKey, {
                        title: portalInfo.title,
                        lat: portalInfo.latE6 / 1e6,
                        lng: portalInfo.lngE6 / 1e6,
                        team: capturerTeam,
                        history: new Map(),
                    });
                }
                return site.portals.get(portalKey);
            }

            function addToPortalHistory(portal, shardId, historyItem) {
                if (!portal.history.has(shardId)) {
                    portal.history.set(shardId, []);
                }
                portal.history.get(shardId).push({
                    moveTimeMs: historyItem.moveTimeMs,
                    reason: historyItem.reason,
                });
            }

            function getLinkRule(rules, distance) {
                for (const rule of rules.rules) {
                    if (distance >= rule.minDistance && distance < rule.maxDistance) {
                        return rule;
                    }
                }
                return null;
            }

            function calculateJsonSizeReduction(name, originalJson, shardEventDataJson) {
                const originalSize = JSON.stringify(originalJson).length;
                const plottableSize = JSON.stringify(Array.from(shardEventDataJson.values())).length;
                return `${name} - original JSON size: ${originalSize} bytes, converted Shard Event Data size: ${plottableSize} bytes, Reduction: ${(
                    (1 - plottableSize / originalSize) *
                    100
                ).toFixed(2)}%`;
            }

            function renderShardEventData(name, shardEventData) {
                const seriesLayer = L.featureGroup();
                layer_lookup[name] = seriesLayer;
                layerControl.addOverlay(seriesLayer, name);

                let controlsHtml = `<div id="${name}" class="series" style="display:none">`;

                shardEventData.forEach((site, siteId) => {
                    console.debug(`Rendering site: ${site.name} (${siteId})`);
                    const layer = L.featureGroup().addTo(seriesLayer);
                    layer.data = site;

                    const linkedPortalColors = new Map();
                    site.shards.forEach((shard) => {
                        const renderedLinks = renderShardLinks({
                            shard,
                            site,
                            linkedPortalColors,
                        });

                        if (renderedLinks.length > 0) {
                            const movingShard = renderMovingShard(renderedLinks);
                            movingShard.forEach((shard) => shard.addTo(layer));
                            renderedLinks.forEach((polyline) => polyline.addTo(layer));
                        }
                    });

                    site.portals.forEach((portal, key) => {
                        renderPortal({
                            key,
                            portal,
                            color: linkedPortalColors.get(key) || factionColors[portal.team] || factionColors.NEUTRAL,
                            timezone: site.timezone,
                            hasUnmovedShard: !linkedPortalColors.has(key),
                        }).forEach((marker) => marker.addTo(layer));
                    });

                    const uniqueSiteId = name + "_" + siteId.replace(" ", "_");
                    layer_lookup[uniqueSiteId] = layer;
                    const scoresHtml = `<span style="color:${factionColors.RESISTANCE}">${site.linkScores.RESISTANCE}</span>:<span style="color:${factionColors.ENLIGHTENED}">${site.linkScores.ENLIGHTENED}</span>:<span style="color:${factionColors.MACHINA}">${site.linkScores.MACHINA}</span>:<span style="color:${factionColors.NEUTRAL}">${site.linkScores.NEUTRAL}</span>`;
                    controlsHtml += `<button id="${uniqueSiteId}">${site.name}</button> ${scoresHtml}<br>`;
                });
                controlsHtml += "</div>";
                $("#controls").append(controlsHtml);
            }

            function renderShardLinks(shardDetails) {
                const site = shardDetails.site;
                const shard = shardDetails.shard;
                const linkedPortalColors = shardDetails.linkedPortalColors;

                return (
                    Array.from(shard.links.values()).map((link) => {
                        const originPortal = site.portals.get(link.originPortal);
                        const destPortal = site.portals.get(link.destinationPortal);
                        if (!originPortal || !destPortal) {
                            console.warn(
                                `Missing portal data for link: ${link.originPortal} to ${link.destinationPortal}`
                            );
                            return;
                        }

                        const linkColor = factionColors[link.linkCreatorTeam] || factionColors.NEUTRAL;
                        const polyline = L.polyline(
                            [L.latLng(originPortal.lat, originPortal.lng), L.latLng(destPortal.lat, destPortal.lng)],
                            {
                                color: linkColor,
                                dashArray: ["10,5,5,5,5,5,5,5,100000"],
                            }
                        );

                        const linkCreationTimeMs = new Date(parseInt(link.linkCreationTimeMs)).toLocaleString(
                            navigator.language,
                            {
                                timeZone: site.timezone,
                            }
                        );
                        const moveTimeMs = new Date(parseInt(link.moveTimeMs)).toLocaleString(navigator.language, {
                            timeZone: site.timezone,
                        });
                        const linkTooltip = `<strong>${shard.id}</strong><br />${originPortal.title} -> ${
                            destPortal.title
                        }<br>Link time: ${linkCreationTimeMs}<br />Jump time: ${moveTimeMs}<br />Distance: ${(
                            Math.round((link.distance + Number.EPSILON) * 100) / 100
                        ).toLocaleString()}m<br />Points: ${link.points}`;
                        polyline.bindTooltip(linkTooltip, { sticky: true });
                        polyline.bindPopup(linkTooltip, { sticky: true });

                        linkedPortalColors.set(link.originPortal, linkColor);
                        linkedPortalColors.set(link.destinationPortal, linkColor);

                        return polyline;
                    }) || null
                );
            }

            function renderMovingShard(renderedLinks) {
                const coords = renderedLinks.map((line) => line.getLatLngs()).flat();
                const animatedShards = [
                    L.motion.polyline(
                        coords,
                        {
                            color: "transparent",
                            interactive: false,
                        },
                        { auto: true, duration: renderedLinks.length * 1000 },
                        {
                            showMarker: true,
                            removeOnEnd: false,
                            icon: shardIcon,
                            interactive: false,
                        }
                    ),
                ];
                for (const polyline of renderedLinks) {
                    polyline.animatedShards = animatedShards;
                    polyline.on("mouseover", function (e) {
                        this.animatedShards.forEach((s) => s.motionStart());
                    });
                }
                return animatedShards;
            }

            function renderPortal(portalDetails) {
                const portal = portalDetails.portal;
                const latLng = L.latLng(portal.lat, portal.lng);
                let portalTooltip = `<strong>${portal.title}</strong><br />`;
                portal.history.forEach((shardHistory, shardId) => {
                    portalTooltip += `<hr /><strong>${shardId}</strong><br />`;
                    shardHistory.forEach((historyItem) => {
                        portalTooltip += `${historyItem.reason} at ${new Date(
                            parseInt(historyItem.moveTimeMs)
                        ).toLocaleString(navigator.language, {
                            timeZone: portalDetails.timezone,
                        })}<br />`;
                    });
                });

                const markers = [L.circleMarker(latLng, { color: portalDetails.color }).bindTooltip(portalTooltip)];
                // render a shard which didn't move from this portal
                if (portalDetails.hasUnmovedShard) {
                    markers.push(L.marker(latLng, { icon: shardIcon }).bindTooltip(portalTooltip));
                }
                return markers;
            }

            var json_files = {
                "Shared Memories 2024 APAC": "shard-jump-times-2024.09.01.18.10.48.json",
                "Erased Memories 2024 AMER": "shard-jump-times-2024.11.17.09.14.04.json",
                "+Alpha 2025 EMEA": "shard-jump-times-2025.03.01.20.11.38.json",
                "+Alpha 2025 APAC": "shard-jump-times-2025.03.09.08.41.46.json",
                "+Alpha 2025 AMER": "shard-jump-times-2025.03.17.09.45.57.json",
                "+Theta 2025-05-24 Shard Singular": "shard-jump-times-2025.05.25.13.14.05.json",
                "+Theta 2025 EMEA": "shard-jump-times-2025.05.25.13.14.05.json",
                "+Theta 2025-05-31 Shard Singular": "shard-jump-times-2025.06.03.15.20.36.json",
                "+Theta 2025 AMER": "shard-jump-times-2025.06.03.15.20.36.json",
                "+Theta 2025-06-07 Shard Singular": "shard-jump-times-2025.06.08.12.07.39.json",
                "+Theta 2025 APAC": "shard-jump-times-2025.06.08.12.07.39.json",
                "+Theta 2025-06-14": "shard-jump-times-2025.06.16.17.47.43.json",
                "+Delta 2025-08-16": "shard-jump-times-2025.08.18.12.11.03.json",
                "+Delta 2025-08-23": "shard-jump-times-2025.08.23.22.03.28.json",
            };

            async function initDataPipeline() {
                try {
                    _shardEventData = await loadAndParseShardData();
                    console.debug("Shard data loaded successfully:", _shardEventData);
                    loadingProgress.value = 66;
                    await new Promise(requestAnimationFrame);

                    await processAndRenderShards();

                    loadingProgress.value = 100;
                    await new Promise(requestAnimationFrame);

                    initMapState();

                    setTimeout(() => (loadingOverlay.style.display = "none"), 500);
                } catch (error) {
                    console.error("Error loading shard data:", error);
                    loadingProgress.value = 0;
                }
            }

            async function loadAndParseShardData() {
                const startTime = performance.now();
                loadingProgress.value = 0;

                const response = await fetch("all_data.json");
                if (!response.ok) {
                    console.error("Failed to fetch all_data.json:", response.statusText);
                    return;
                }
                const fetchTime = performance.now();
                console.log(`fetch time is : ${fetchTime - startTime} milliseconds`);

                const contentLength = response.headers.get("content-length");
                const total = parseInt(contentLength, 10);
                let loaded = 0;

                const reader = response.body.getReader();
                const chunks = [];

                while (true) {
                    const { done, value } = await reader.read();
                    if (done) {
                        break;
                    }
                    chunks.push(value);
                    loaded += value.length;
                    loadingProgress.value = (loaded / total) * 33; // 0-33% for download
                }

                const combinedChunks = concatUint8Arrays(chunks);
                const rawJsonString = new TextDecoder().decode(combinedChunks);

                loadingProgress.value = 33; // Move to 33% for parsing

                return new Promise((resolve, reject) => {
                    jsonParserWorker = new Worker("json-parser-worker.js");

                    jsonParserWorker.onmessage = (event) => {
                        if (event.data.status === "complete") {
                            const parseTime = performance.now();
                            console.log(`parse time is : ${parseTime - fetchTime} milliseconds`);

                            resolve(event.data.data);
                        } else if (event.data.status === "error") {
                            console.error("Web Worker error:", event.data.message);
                            loadingProgress.value = 0; // Reset progress
                            loadingOverlay.style.display = "flex"; // Keep overlay visible on error
                            reject(new Error(event.data.message));
                        }
                    };

                    jsonParserWorker.onerror = (error) => {
                        console.error("Web Worker general error:", error);
                        loadingProgress.value = 0; // Reset progress
                        loadingOverlay.style.display = "flex"; // Keep overlay visible on error
                        reject(error);
                    };

                    jsonParserWorker.postMessage(rawJsonString);
                });
            }

            // --- Helper function to concatenate Uint8Arrays ---
            function concatUint8Arrays(arrays) {
                let totalLength = 0;
                for (const arr of arrays) {
                    totalLength += arr.length;
                }
                const result = new Uint8Array(totalLength);
                let offset = 0;
                for (const arr of arrays) {
                    result.set(arr, offset);
                    offset += arr.length;
                }
                return result;
            }

            async function processAndRenderShards() {
                const startTime = performance.now();
                const filesArray = Object.keys(json_files);
                for (let i = 0; i < filesArray.length; i++) {
                    const name = filesArray[i];
                    const safeName = name.replace(/[^a-z0-9]/gi, "_").toLowerCase();

                    $("#series").append(`<option value="${safeName}">${name}</option>`);

                    const json = _shardEventData[json_files[name]];
                    console.debug("Processing shard event data:", safeName);

                    const shardEventData = processShardEventData(safeName, json);
                    renderShardEventData(safeName, shardEventData);

                    loadingProgress.value = 66 + ((i + 1) / filesArray.length) * 34;
                    await new Promise(requestAnimationFrame);
                }
                const endTime = performance.now();
                console.log(`process and render time is : ${startTime - endTime} milliseconds`);
            }

            function initMapState() {
                const hash = location.hash.substring(1).replace("Abaddon_1", "").replace("abaddon1_", "");
                let seriesName = "_delta_2025_08_16";
                if (hash) {
                    seriesName = hash.split("_").slice(0, -1).join("_");
                }

                // We can use a one-time event listener to ensure the button click happens
                // after the layers are displayed.
                $("#series").one("seriesDisplayComplete", () => {
                    console.debug(`Series display complete. Checking hash: ${location.hash}`);
                    if ($(location.hash).length > 0) {
                        $(location.hash).click();
                    }
                });

                $("#series").val(seriesName);
                displaySeries(seriesName, "pageLoad");
            }

            async function displaySeries(seriesName, source = "user") {
                console.debug(`Displaying series layer for: ${seriesName}`);
                $(".series").hide();

                $(`#${seriesName}`).show();
                $("button").off("click").on("click", buttonHandler);

                if (currentActiveSeriesLayer && map.hasLayer(currentActiveSeriesLayer)) {
                    map.removeLayer(currentActiveSeriesLayer);
                }
                const newSeriesLayer = layer_lookup[seriesName];
                if (newSeriesLayer) {
                    layer_lookup[seriesName].addTo(map);
                    currentActiveSeriesLayer = newSeriesLayer;

                    if (source === "user" || location.hash === "") {
                        map.fitBounds(currentActiveSeriesLayer.getBounds());
                    }

                    $("#series").trigger("seriesDisplayComplete");
                } else {
                    console.warn(`No layer found for series: ${seriesName}`);
                }

                $("#series")
                    .off("change")
                    .on("change", function () {
                        displaySeries(this.value);
                    });
            }

            function buttonHandler() {
                var layer = layer_lookup[this.id];
                map.fitBounds(layer.getBounds());
                location.hash = this.id;
                layer.eachLayer(function (l) {
                    if (l instanceof L.Polyline) {
                        if (l.animatedShards) l.animatedShards.forEach((s) => s.motionStart());
                    }
                });
                var d = layer.data;
                //console.log(d.fragment.map(f => f.history.map(h => new Date(parseInt(h.moveTimeMs)))))
            }

            async function handleCustomFile() {
                var file = this.files[0];
                if (!file) return;

                loadingOverlay.style.display = "flex";
                loadingProgress.value = 0;
                await new Promise(requestAnimationFrame);

                let reader = new FileReader();
                reader.onload = async function (e) {
                    const localRawJsonString = e.target.result;
                    loadingProgress.value = 33;
                    await new Promise(requestAnimationFrame);

                    jsonParserWorker.postMessage(localRawJsonString);
                    jsonParserWorker.onmessage = async (workerEvent) => {
                        if (workerEvent.data.status === "complete") {
                            loadingProgress.value = 66;
                            await new Promise(requestAnimationFrame);

                            const parsedJson = workerEvent.data.data;
                            const name = file.name.replace(/[^a-z0-9]/gi, "_").toLowerCase();
                            const shardEventData = processShardEventData(name, parsedJson);

                            _shardEventData[name] = shardEventData;
                            renderShardEventData(name, shardEventData);

                            $("#series").append(`<option value="${name}">${file.name}</option>`);
                            $("#series").val(name).change();
                            $("button").off("click").on("click", buttonHandler);

                            loadingProgress.value = 100;
                            setTimeout(() => (loadingOverlay.style.display = "none"), 500);
                        }
                    };
                };
                reader.readAsText(file);
            }

            $(() => {
                $("#custom").change(handleCustomFile);
                initDataPipeline();
            });
        </script>
    </body>
</html>
