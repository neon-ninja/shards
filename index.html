<!DOCTYPE html>
<html lang="en">
    <head>
        <base target="_top" />
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <meta property="og:image" content="https://neon-ninja.github.io/shards/screenshot.png" />
        <link
            rel="icon"
            type="image/png"
            href="//commondatastorage.googleapis.com/ingress.com/img/map_icons/marker_images/abaddon1_shard.png"
            sizes="60x60" />
        <title>Ingress Shards</title>
        <link
            rel="stylesheet"
            href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
            integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
            crossorigin="" />
        <link
            rel="stylesheet"
            href="https://cdnjs.cloudflare.com/ajax/libs/github-fork-ribbon-css/0.2.3/gh-fork-ribbon.min.css" />
        <script
            src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
            integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
            crossorigin=""></script>
        <script src="https://unpkg.com/leaflet-providers@latest/leaflet-providers.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.7.1/jquery.min.js"></script>
        <script src="https://neon-ninja.github.io/leaflet.motion/dist/leaflet.motion.min.js"></script>
        <style>
            html,
            body,
            #map {
                height: 100%;
                width: 100%;
                margin: 0;
            }

            button {
                font-family: "Twemoji Country Flags", sans-serif;
            }

            #controls {
                position: absolute;
                right: 10px;
                bottom: 20px;
                background-color: white;
                z-index: 9999;
                padding: 10px;
                border-radius: 10px;
                display: grid;
                grid-template-columns: 1fr;
                min-width: 15%;
                min-height: 10%;
            }

            #controls #loading-overlay {
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.7);
                color: white;
                display: flex;
                flex-direction: column;
                justify-content: center;
                align-items: center;
                z-index: 10;
                border-radius: 10px;
            }

            #controls #loading-overlay h3 {
                margin-block: 0 0.5em;
            }

            #controls #loading-progress {
                width: 80%;
                margin-top: 5px;
            }

            #controls span {
                font-weight: bold;
            }

            .github-fork-ribbon:before {
                background-color: #333;
            }
        </style>
    </head>

    <body>
        <script type="module" defer>
            import { polyfillCountryFlagEmojis } from "https://cdn.skypack.dev/country-flag-emoji-polyfill";
            polyfillCountryFlagEmojis();
        </script>
        <div id="map"></div>
        <div id="controls">
            <div id="loading-overlay">
                <h3 id="loading-message">Loading Shard Data...</h3>
                <progress id="loading-progress" value="0" max="100"></progress>
            </div>

            <select id="series">
                <option value="custom">Custom</option>
            </select>
            <br />
            <input id="custom" class="series" type="file" accept="application/json" style="display: none" />
        </div>
        <a
            class="github-fork-ribbon"
            href="https://github.com/neon-ninja/shards"
            data-ribbon="Fork me on GitHub"
            title="Fork me on GitHub"
            >Fork me on GitHub</a
        >

        <script type="module">
            import { shardSeries, getSeriesSafeName } from "./shard-series-metadata.js";
            import { HISTORY_REASONS } from "./shard-data-processor.js";

            window.map = L.map("map", {
                worldCopyJump: true,
            }).fitWorld();
            var baseMaps = {
                OSM: L.tileLayer.provider("OpenStreetMap.Mapnik"),
                "CartoDB Positron": L.tileLayer.provider("CartoDB.Positron"),
                "CartoDB Dark Matter": L.tileLayer.provider("CartoDB.DarkMatter").addTo(map),
                "ESRI WorldImagery": L.tileLayer.provider("Esri.WorldImagery"),
                "Google Hybrid": L.tileLayer("http://{s}.google.com/vt/lyrs=s,h&x={x}&y={y}&z={z}", {
                    maxZoom: 20,
                    subdomains: ["mt0", "mt1", "mt2", "mt3"],
                }),
            };
            const factionColors = {
                NEU: "#FF6600",
                RES: "#0088FF",
                ENL: "#03DC03",
                MAC: "#FF0028",
                NOT_SPECIFIED: "#FF6600",
                undefined: "#FF6600",
            };
            const layerControl = L.control.layers(baseMaps, {}, { position: "topleft" }).addTo(map);

            const shardIcon = L.icon({
                iconUrl:
                    "//commondatastorage.googleapis.com/ingress.com/img/map_icons/marker_images/abaddon1_shard.png",
                iconSize: [30, 30],
                iconAnchor: [15, 15],
            });

            window.layer_lookup = {};
            let currentActiveSeriesLayer = null;
            let _shardSeriesData = {};
            let jsonParserWorker = null;

            async function initDataPipeline() {
                try {
                    _shardSeriesData = await loadAndParseShardData();
                    console.debug(
                        `Shard data loaded successfully: ${_shardSeriesData.length} series, ${
                            _shardSeriesData.flatMap((event) => event.sites || []).length
                        } sites`
                    );
                    renderSeriesSelection();

                    let prioritySeriesDetails = getPrioritySeriesDetails(location.hash);
                    let data = _shardSeriesData.find((e) => e.name === prioritySeriesDetails.seriesSafeName);
                    if (!data) {
                        console.warn(
                            `Priority series ${prioritySeriesDetails.seriesSafeName} not found, defaulting to latest series`
                        );
                        prioritySeriesDetails = getPrioritySeriesDetails();
                        data = _shardSeriesData.find((e) => e.name === prioritySeriesDetails.seriesSafeName);
                    }
                    prioritySeriesDetails.data = data;

                    if (prioritySeriesDetails.data) {
                        console.log(`Rendering priority series: ${prioritySeriesDetails.seriesSafeName}`);
                        renderSeriesData(prioritySeriesDetails.seriesSafeName, prioritySeriesDetails.data);

                        $("#series").one("seriesDisplayComplete", () => {
                            console.debug(
                                `Series display complete. ${
                                    location.hash.length > 0 ? `Displaying site ${location.hash}` : ""
                                }`
                            );
                            if ($(location.hash).length > 0) {
                                $(location.hash).click();
                            }
                        });

                        $("#series").val(prioritySeriesDetails.seriesSafeName);
                        displaySeries(prioritySeriesDetails.seriesSafeName, "page_load");
                    }

                    renderBackgroundSeries(prioritySeriesDetails);
                } catch (error) {
                    console.error("Error loading shard data:", error);
                    loadingProgress.value = 0;
                }
            }

            async function loadAndParseShardData() {
                const startTime = performance.now();
                updateLoadingDetails(0, "Loading Shard Data...");

                const response = await fetch("processed_shard_series.json");
                if (!response.ok) {
                    console.error("Failed to fetch processed_shard_series.json:", response.statusText);
                    return;
                }
                const fetchTime = performance.now();
                console.debug(`Data fetch time is : ${fetchTime - startTime} milliseconds`);

                const contentLength = response.headers.get("content-length");
                const total = parseInt(contentLength, 10);
                let loaded = 0;

                const reader = response.body.getReader();
                const chunks = [];

                while (true) {
                    const { done, value } = await reader.read();
                    if (done) {
                        break;
                    }
                    chunks.push(value);
                    loaded += value.length;
                    updateLoadingDetails((loaded / total) * 33);
                }

                const combinedChunks = concatUint8Arrays(chunks);
                const rawJsonString = new TextDecoder().decode(combinedChunks);
                updateLoadingDetails(33);

                return new Promise((resolve, reject) => {
                    jsonParserWorker = new Worker("json-parser-worker.js", { type: "module" });

                    jsonParserWorker.onmessage = (event) => {
                        if (event.data.status === "complete") {
                            const parseTime = performance.now();
                            console.debug(`Data parse time is : ${parseTime - fetchTime} milliseconds`);
                            updateLoadingDetails(66, "Rendering shard data...");

                            resolve(event.data.data);
                        } else if (event.data.status === "error") {
                            console.error("Web Worker error:", event.data.message);
                            updateLoadingDetails(0, "Error loading shard data.");
                            reject(new Error(event.data.message));
                        }
                    };

                    jsonParserWorker.onerror = (error) => {
                        console.error("Web Worker general error:", error);
                        updateLoadingDetails(0, "Error loading shard data.");
                        reject(error);
                    };

                    jsonParserWorker.postMessage({ rawData: rawJsonString });
                });
            }

            // --- Helper function to concatenate Uint8Arrays ---
            function concatUint8Arrays(arrays) {
                let totalLength = 0;
                for (const arr of arrays) {
                    totalLength += arr.length;
                }
                const result = new Uint8Array(totalLength);
                let offset = 0;
                for (const arr of arrays) {
                    result.set(arr, offset);
                    offset += arr.length;
                }
                return result;
            }

            function renderSeriesSelection() {
                const shardSeriesNames = shardSeries.flatMap((s) => s.seriesName);
                for (const seriesName of shardSeriesNames) {
                    $("#series").append(`<option value="${getSeriesSafeName(seriesName)}">${seriesName}</option>`);
                }
            }

            function updateLoadingDetails(progress, message) {
                const loadingOverlay = document.getElementById("loading-overlay");
                const loadingMessage = document.getElementById("loading-message");
                const loadingProgress = document.getElementById("loading-progress");

                if (progress !== undefined) {
                    loadingProgress.value = progress;
                }
                if (message) {
                    loadingMessage.textContent = message;
                }
                if (progress >= 100) {
                    setTimeout(() => (loadingOverlay.style.display = "none"), 500);
                } else {
                    loadingOverlay.style.display = "flex";
                }
            }

            function getPrioritySeriesDetails(locationHash) {
                let siteName =
                    locationHash && locationHash.substring(1).replace("Abaddon_1", "").replace("abaddon1_", "");
                let seriesSafeName = getSeriesSafeName(shardSeries.at(-1).seriesName);
                if (siteName) {
                    seriesSafeName = siteName.split("_").slice(0, -1).join("_");
                }
                return {
                    seriesSafeName,
                    siteName,
                };
            }

            async function renderSeriesData(name, shardEventData) {
                const startTime = performance.now();
                const seriesLayer = L.featureGroup();
                layer_lookup[name] = seriesLayer;
                layerControl.addOverlay(seriesLayer, name);

                let controlsHtml = `<div id="${name}" class="series" style="display:none">`;

                console.log(`Rendering sites for series: ${name}`);
                for (const site of shardEventData.sites) {
                    const siteLayer = L.featureGroup().addTo(seriesLayer);
                    siteLayer.data = site;

                    const shardDetails = renderShardData(site.shards, site.portals);
                    shardDetails.links.forEach((link) => link.addTo(siteLayer));
                    shardDetails.paths.forEach((path) => path.addTo(siteLayer));

                    const portalHistoryMap = shardDetails.portalHistoryMap;
                    const portalDetails = renderPortalData(site.portals, portalHistoryMap, site.timezone);
                    portalDetails.markers.forEach((marker) => marker.addTo(siteLayer));
                    portalDetails.staticShards.forEach((marker) => marker.addTo(siteLayer));

                    console.debug(
                        `${site.name} site details: ${shardDetails.portalHistoryMap.size} portals, ${site.shards.length} shards (${portalDetails.staticShards.length} static), ${shardDetails.links.length} links.`
                    );

                    const uniqueSiteId = name + "_" + site.id.replace(" ", "_");
                    layer_lookup[uniqueSiteId] = siteLayer;
                    const scoresHtml = `<span style="color:${factionColors.RES}">${site.linkScores.RES}</span>:<span style="color:${factionColors.ENL}">${site.linkScores.ENL}</span>:<span style="color:${factionColors.MAC}">${site.linkScores.MAC}</span>:<span style="color:${factionColors.NEU}">${site.linkScores.NEU}</span>`;
                    controlsHtml += `<button id="${uniqueSiteId}">${site.name}</button> ${scoresHtml}<br>`;
                }
                controlsHtml += "</div>";
                $("#controls").append(controlsHtml);

                const endTime = performance.now();
                console.debug(
                    `Render of ${name} (${shardEventData.sites.length} sites) complete in ${
                        endTime - startTime
                    } milliseconds`
                );
            }

            function renderLink(linkMetadata) {
                const originPortal = linkMetadata.originPortal;
                const destPortal = linkMetadata.destPortal;
                const linkColor = factionColors[linkMetadata.team] || factionColors.NEU;

                const polyline = L.polyline(
                    [L.latLng(originPortal.lat, originPortal.lng), L.latLng(destPortal.lat, destPortal.lng)],
                    {
                        color: linkColor,
                        dashArray: ["10,5,5,5,5,5,5,5,100000"],
                    }
                );

                const linkCreationTimeMs = new Date(parseInt(linkMetadata.linkTime) * 1000).toLocaleString(
                    navigator.language,
                    {
                        timeZone: originPortal.timezone,
                    }
                );
                const moveTimeMs = new Date(parseInt(linkMetadata.moveTime) * 1000).toLocaleString(navigator.language, {
                    timeZone: originPortal.timezone,
                });
                const linkTooltip = `<strong>Shard ${linkMetadata.shardId}</strong><br />${originPortal.title} -> ${
                    destPortal.title
                }<br>Link time: ${linkCreationTimeMs}<br />Jump time: ${moveTimeMs}<br />Distance: ${(
                    Math.round((linkMetadata.distance + Number.EPSILON) * 100) / 100
                ).toLocaleString()}m<br />Points: ${linkMetadata.points}`;
                polyline.bindTooltip(linkTooltip, { sticky: true });
                polyline.bindPopup(linkTooltip, { sticky: true });

                return polyline;
            }

            function getLastKnownTeam(portalHistory) {
                if (!portalHistory) {
                    return undefined;
                }

                const portalHistoryEntries = [...portalHistory.values()]
                    .flatMap((historyItem) => historyItem || [])
                    .filter(
                        (historyItem) =>
                            historyItem.reason !== "despawn" && (historyItem.team || historyItem.linkDetails?.team)
                    )
                    .sort((a, b) => b.moveTime - a.moveTime);

                return portalHistoryEntries[0]?.team || portalHistoryEntries[0]?.linkDetails?.team;
            }

            function renderShardData(shards, portalsMap) {
                const portalHistoryMap = new Map();
                const allLinks = [];
                const shardPaths = [];

                for (const shard of shards) {
                    const shardLinks = [];
                    for (const historyItem of shard.history) {
                        let portalIds = [];
                        switch (historyItem.reason) {
                            case HISTORY_REASONS.LINK:
                            case HISTORY_REASONS.JUMP:
                                portalIds.push(historyItem.linkDetails.origin, historyItem.linkDetails.dest);
                                const originPortal = portalsMap.get(historyItem.linkDetails.origin);
                                const destPortal = portalsMap.get(historyItem.linkDetails.dest);

                                shardLinks.push(
                                    renderLink({
                                        ...historyItem.linkDetails,
                                        originPortal,
                                        destPortal,
                                        shardId: shard.id,
                                        moveTime: historyItem.moveTime,
                                    })
                                );
                                break;
                            default:
                                portalIds.push(historyItem.portalId);
                                break;
                        }

                        for (const portalId of portalIds) {
                            if (!portalHistoryMap.has(portalId)) {
                                portalHistoryMap.set(portalId, new Map());
                            }
                            const portalHistory = portalHistoryMap.get(portalId);
                            if (!portalHistory.has(shard.id)) {
                                portalHistory.set(shard.id, []);
                            }
                            portalHistoryMap.get(portalId).get(shard.id).push(historyItem);
                        }
                    }

                    if (shardLinks.length > 0) {
                        const coords = shardLinks.flatMap((link) => link.getLatLngs());

                        const shardPath = [
                            L.motion.polyline(
                                coords,
                                {
                                    color: "transparent",
                                    interactive: false,
                                },
                                { auto: true, duration: shardLinks.length * 1000 },
                                {
                                    showMarker: true,
                                    removeOnEnd: false,
                                    icon: shardIcon,
                                    interactive: false,
                                }
                            ),
                        ];

                        for (const link of shardLinks) {
                            link.shardPath = shardPath;
                            link.on("mouseover", function (e) {
                                this.shardPath.forEach((s) => s.motionStart());
                            });
                        }
                        shardPaths.push(...shardPath);
                        allLinks.push(...shardLinks);
                    } else {
                        const portal = portalsMap.get(shard.history[shard.history.length - 1].portalId);
                        const latLng = L.latLng(portal.lat, portal.lng);
                    }
                }

                return {
                    links: allLinks,
                    paths: shardPaths,
                    portalHistoryMap,
                };
            }

            function renderPortalData(portals, portalHistoryMap, timeZone) {
                const markers = [];
                const staticShards = [];

                for (const [portalId, portal] of portals) {
                    const latLng = L.latLng(portal.lat, portal.lng);

                    const portalHistory = portalHistoryMap.get(portalId);
                    const lastKnownTeam = getLastKnownTeam(portalHistory);

                    let portalTooltip = `<strong>${portal.title}</strong><br />`;
                    for (const [shardId, shardHistory] of portalHistory || []) {
                        portalTooltip += `<hr /><strong>Shard ${shardId}</strong><br />`;
                        const hasStaticShard = true;
                        for (const historyItem of shardHistory) {
                            let teamToDisplay =
                                historyItem.reason !== HISTORY_REASONS.NO_MOVE
                                    ? historyItem.team || historyItem.linkDetails?.team || "NEU"
                                    : undefined;

                            portalTooltip += `${
                                historyItem.reason === HISTORY_REASONS.LINK ? HISTORY_REASONS.JUMP : historyItem.reason
                            } at ${new Date(parseInt(historyItem.moveTime) * 1000).toLocaleString(navigator.language, {
                                timeZone,
                            })}${
                                teamToDisplay
                                    ? ` - <span style="color:${factionColors[teamToDisplay]}">${teamToDisplay}</span>`
                                    : ""
                            } <br />`;
                        }

                        const shardHistoryReasons = shardHistory.flatMap((h) => h.reason);
                        if (
                            shardHistoryReasons.includes(HISTORY_REASONS.SPAWN) &&
                            shardHistoryReasons.includes(HISTORY_REASONS.DESPAWN)
                        ) {
                            staticShards.push(L.marker(latLng, { icon: shardIcon }).bindTooltip(portalTooltip));
                        }
                    }
                    markers.push(
                        L.circleMarker(latLng, {
                            color: factionColors[lastKnownTeam] || factionColors.NEU,
                        }).bindTooltip(portalTooltip)
                    );
                }
                return {
                    markers,
                    staticShards,
                };
            }

            let backgroundRenderQueue = [];
            let totalSeriesToRender = 0;
            let seriesRendered = 0;

            async function renderBackgroundSeries(prioritySeries) {
                const seriesToRender = _shardSeriesData.filter((event) => {
                    return getSeriesSafeName(event.name) !== prioritySeries.seriesSafeName;
                });

                seriesToRender.forEach((event) => {
                    backgroundRenderQueue.push({ event, safeName: getSeriesSafeName(event.name) });
                });
                totalSeriesToRender = backgroundRenderQueue.length;
                console.log(`Total series to render in background: ${totalSeriesToRender}`);
                seriesRendered = 0;

                requestIdleCallback(renderNextSeries);
            }

            async function renderNextSeries(deadline) {
                while (deadline.timeRemaining() > 0 && backgroundRenderQueue.length > 0) {
                    const nextItem = backgroundRenderQueue.shift();
                    const { event, safeName } = nextItem;

                    renderSeriesData(safeName, event);
                    seriesRendered++;
                    updateLoadingDetails(66 + (seriesRendered / totalSeriesToRender) * 34);

                    if (seriesRendered % 2 === 0) {
                        await new Promise(requestAnimationFrame);
                    }
                }

                if (backgroundRenderQueue.length > 0) {
                    requestIdleCallback(renderNextSeries);
                } else {
                    console.log("Background rendering complete.");
                    updateLoadingDetails(100);
                }
            }

            async function displaySeries(seriesName, source = "user") {
                console.debug(`Displaying series layer for: ${seriesName}`);
                $(".series").hide();

                $(`#${seriesName}`).show();
                $("button").off("click").on("click", buttonHandler).css("font-weight", "normal");

                if (currentActiveSeriesLayer && map.hasLayer(currentActiveSeriesLayer)) {
                    map.removeLayer(currentActiveSeriesLayer);
                }
                const newSeriesLayer = layer_lookup[seriesName];
                if (newSeriesLayer) {
                    layer_lookup[seriesName].addTo(map);
                    currentActiveSeriesLayer = newSeriesLayer;

                    if (source === "user" || location.hash === "" || !layer_lookup[location.hash.substring(1)]) {
                        map.fitBounds(currentActiveSeriesLayer.getBounds());
                    }

                    $("#series").trigger("seriesDisplayComplete");
                } else {
                    console.warn(`No layer found for series: ${seriesName}`);
                }
            }

            function buttonHandler() {
                $(this).css("font-weight", "bold");
                $(this).siblings("button").css("font-weight", "normal");

                var layer = layer_lookup[this.id];
                map.fitBounds(layer.getBounds());
                location.hash = this.id;
                layer.eachLayer(function (l) {
                    if (l instanceof L.Polyline) {
                        if (l.shardPath) l.shardPath.forEach((s) => s.motionStart());
                    }
                });
                var d = layer.data;
            }

            async function handleCustomFile() {
                var file = this.files[0];
                if (!file) return;

                updateLoadingDetails(0, "Loading custom shard data...");
                await new Promise(requestAnimationFrame);

                let reader = new FileReader();
                reader.onload = async function (e) {
                    const localRawJsonString = e.target.result;
                    updateLoadingDetails(33);
                    await new Promise(requestAnimationFrame);

                    const seriesSafeName = getSeriesSafeName(file.name);
                    jsonParserWorker.postMessage({
                        rawData: localRawJsonString,
                        seriesSafeName,
                        processType: "custom_file",
                    });
                    jsonParserWorker.onmessage = async (workerEvent) => {
                        if (workerEvent.data.status === "complete") {
                            updateLoadingDetails(66, "Rendering shard data...");
                            await new Promise(requestAnimationFrame);

                            const customShardSeriesData = workerEvent.data.data;

                            _shardSeriesData[seriesSafeName] = customShardSeriesData;
                            renderSeriesData(seriesSafeName, customShardSeriesData);

                            $("#series").append(`<option value="${seriesSafeName}">${file.name}</option>`);
                            $("#series").val(seriesSafeName).change();
                            $("button").off("click").on("click", buttonHandler);

                            updateLoadingDetails(100);
                        }
                    };
                };
                reader.readAsText(file);
            }

            $(() => {
                $("#custom").change(handleCustomFile);
                $("#series").on("change", function () {
                    displaySeries(this.value);
                });

                initDataPipeline();
            });
        </script>
    </body>
</html>
